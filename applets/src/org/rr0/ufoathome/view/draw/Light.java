package org.rr0.ufoathome.view.draw;//------------------------------------------------------------------------// AlphaBlending Applet//// Shows how to make nice fade/opacity effects between different images// The basic is very near to the RGB split applet.//// (Ooooh...Yes, the sinus func is the same of the sinus applet...well// how many math functions you know to draw a sine?!?!?)////// Ok, let's say you wanna implement/change this shitty code....What about// giving me something lika credit?!?!?//													(c) El Viscido 1998//////	Look Out for more at://	http://www.geocities.com/ResearchTriangle/Lab/4841/index2.html//------------------------------------------------------------------------import java.applet.Applet;import java.awt.*;import java.awt.image.MemoryImageSource;import java.awt.image.PixelGrabber;public class Light extends Applet implements Runnable {    // Gonna beat my personal 'private' record....    private Thread m_Light = null;    private Image offscreen,    lightsrc[],    ultima;    private Graphics gfx;    private int maskadd_red = 0,    maskadd_green = 0,    maskadd_blue = 0,    nowonshow = -1;    private double rad = 20.0,    rad_inc = 0.5,    RAD = 3.1415926535 / 180,    ang_x = 0.0,    angolo_x = 0.0,    inc_factor = 3.2;    private boolean factoractive = false;    private boolean doneloading;    private int outp_image[],    imagepic[],    imagepic_red[],    imagepic_green[],    imagepic_blue[],    light_red[],    light_green[],    light_blue[],    light_data[];    private int extent_x,    light_x,    light_y,    extent_y;    private MemoryImageSource screenMem;    private boolean asodreadisegna = true;    private Image tmppic;    // Yeah! I made it!    public Light() {    }    public void init() {        doneloading = false;        lightsrc = new Image[5];        // Loads picture        MediaTracker tracker = new MediaTracker(this);        tmppic = getImage(getDocumentBase(), getParameter("image"));        try {            tracker.waitForID(0);        } catch (Exception e) {        }    ;        tracker.addImage(tmppic, 0);        //Loads multiple images        //NOTE: Check out the on-going parameter build (leee WHAT?!?!)        for (int tempora = 0; tempora < 5; tempora++) {            lightsrc[tempora] = getImage(getDocumentBase(), getParameter("source" + (tempora + 1)));            try {                tracker.waitForID(tempora + 1);            } catch (Exception e) {                e.printStackTrace();            }        ;            tracker.addImage(lightsrc[tempora], tempora + 1);        }        // Now, just try to do it in a different way...it just won't work....        while ((light_x = lightsrc[0].getWidth(this)) < 0)            try {                Thread.sleep(100);            } catch (InterruptedException e) {            }        while ((light_y = lightsrc[0].getHeight(this)) < 0)            try {                Thread.sleep(100);            } catch (InterruptedException e) {            }        extent_x = (size().width + 2) / 2;        extent_y = size().height / 2;        //Gimme space baby...        light_y++;        extent_y++;        //Overlayed (how do u write it?) image data        light_data = new int[light_x * light_y];        light_red = new int[light_x * light_y];        light_green = new int[light_x * light_y];        light_blue = new int[light_x * light_y];        //Output image data        //Gaining speed the lame way: the output picture is half the applet =-)        imagepic = new int[extent_x * extent_y];        imagepic_red = new int[extent_x * extent_y];        imagepic_green = new int[extent_x * extent_y];        imagepic_blue = new int[extent_x * extent_y];        outp_image = new int[extent_x * extent_y];        //Pixelgrabber for output picture        loadPix();        //Pixelgrabber for the first overlayaradf (ARGH!) image        loadImgPix(0);        //Guess...        doAlpha();        offscreen = createImage(extent_x, extent_y);        gfx = offscreen.getGraphics();        screenMem = new MemoryImageSource(extent_x,                        extent_y,                        outp_image,                        0,                        extent_x);        asodreadisegna = false;        doneloading = true;    }    public void destroy() {    }    public void update(Graphics g) {        if (doneloading) {            if (!asodreadisegna) {                gfx.drawImage(ultima, 0, 0, this);                paint(g);            }        } else {            paint(g);        }    }    public void paint(Graphics g) {        if (offscreen != null)            g.drawImage(offscreen, 0, 0, extent_x * 2, extent_y * 2, this);        //Well, I've never seen this. Maybe somethin's going wrong.        if (!doneloading)            g.drawString("Zzzz....", 10, 10);    }    public void start() {        if (m_Light == null) {            m_Light = new Thread(this);            m_Light.start();        }    }    public void stop() {        if (m_Light != null) {            m_Light.stop();            m_Light = null;        }    }    public void run() {        while (true) {            try {                // Don't ask me anymore! 'asodreadisegna' means 'imdrawing'                // It's Bergamasco....                if (!asodreadisegna) {                    doAlpha();                    repaint();                }                Thread.sleep(100);            } catch (InterruptedException e) {                stop();            }        }    }    // I've started with an idea, then another one came out,    // then another one again and i totally forgot about events.    // If you need it, they're here...    public boolean mouseDown(Event evt, int x, int y) {        return true;    }    public boolean mouseUp(Event evt, int x, int y) {        return true;    }    private void doAlpha() {        int punto = 0;        int themask = 0;        int red = 0;        int green = 0;        int blue = 0;        int xstart = (extent_x - light_x) / 2;        int ystart = (extent_y - light_y) / 2;        double CX = 0, CY;        int xadd = 0;        rad += rad_inc;        asodreadisegna = true;        //FAAAAASSSST!        for (int loopx = 0; loopx < extent_x; loopx++) {            for (int loopy = 0; loopy < extent_y - 1; loopy++) {                outp_image[extent_x * loopy + loopx] = imagepic[extent_x * loopy + loopx];            }        }        //Draws the current image on the background, adding opacity frame by frame.        // Extracting colors? Just shift like this...        // Red >> 16        // Green >> 8        // blue (no shift, it's the last one)        for (int loopy = 0; loopy < light_y - 1; loopy++) {            //sinus stuff            angolo_x += inc_factor;            if (angolo_x > 360)                angolo_x = 0;            CX = Math.cos((angolo_x * 2) * RAD);            xadd = (int) ((loopy + 1) * (CX / 3));            //end of sinus stuff            for (int loopx = 0; loopx < light_x - 1; loopx++) {                punto = light_x * loopy + loopx;                maskadd_red = light_red[punto];                maskadd_green = light_green[punto];                maskadd_blue = light_blue[punto];                punto = extent_x * (loopy + ystart) + (loopx + xstart + xadd);                if (punto < (extent_x * extent_y + extent_x) && punto > 0) {                    red = (int) (imagepic_red[punto] + (maskadd_red / rad));                    green = (int) (imagepic_green[punto] + (maskadd_green / rad));                    blue = (int) (imagepic_blue[punto] + (maskadd_blue / rad));                    if (red > 255)                        red = 255;                    if (green > 255)                        green = 255;                    if (blue > 255)                        blue = 255;                    red = red << 16;                    green = green << 8;                    outp_image[punto] = 0xff000000 | (red & 0x00ff0000) | (green & 0x0000ff00) | (blue & 0xff);                }            }        }        // Go lame or go home B}        if (rad > 20) {            angolo_x = 90;            rad_inc = rad_inc * -1;            if (nowonshow == -1)                nowonshow = 1;            else                loadImgPix(nowonshow++);            if (nowonshow == 5)                nowonshow = 0;        }        if (rad < 1) {            rad_inc = rad_inc * -1;        }        // This is supposed to do not work under NetScape...Why life's so dull?        ultima = createImage(screenMem);        asodreadisegna = false;    }    //Loads array data from pic[imagenum]    private void loadImgPix(int imagenum) {        int punto = 0;        int themask = 0;        asodreadisegna = true;        PixelGrabber grabber2 = new PixelGrabber(lightsrc[imagenum],                        0,                        0,                        light_x,                        light_y,                        light_data,                        0,                        light_x);        boolean done = false;        do {            try {                done = grabber2.grabPixels(500);            } catch (InterruptedException e) {            }        } while (!done);        //splitting colors...again.        //I'll keep light_data as well as imagepic arrays, i'll use them        //someways...(did you notice how many periods i use?)        for (int loopx = 0; loopx < light_x - 1; loopx++) {            for (int loopy = 0; loopy < light_y - 1; loopy++) {                punto = light_data[light_x * loopy + loopx];                themask = punto & 0x00ff0000;                light_red[light_x * loopy + loopx] = (themask >> 16);                themask = punto & 0x0000ff00;                light_green[light_x * loopy + loopx] = (themask >> 8);                themask = punto & 0x000000ff;                light_blue[light_x * loopy + loopx] = themask;            }        }        asodreadisegna = false;    }    private void loadPix() {        int punto = 0;        int themask = 0;        asodreadisegna = true;        PixelGrabber grabber = new PixelGrabber(tmppic,                        0,                        0,                        extent_x,                        extent_y,                        imagepic,                        0,                        extent_x);        boolean done = false;        do {            try {                done = grabber.grabPixels(500);            } catch (InterruptedException e) {            }        } while (!done);        for (int loopx = 0; loopx < extent_x - 1; loopx++) {            for (int loopy = 0; loopy < extent_y - 1; loopy++) {                punto = imagepic[extent_x * loopy + loopx];                outp_image[extent_x * loopy + loopx] = imagepic[extent_x * loopy + loopx];                themask = punto & 0x00ff0000;                imagepic_red[extent_x * loopy + loopx] =                        (themask >> 16);                themask = punto & 0x0000ff00;                imagepic_green[extent_x * loopy + loopx] =                        (themask >> 8);                themask = punto & 0x000000ff;                imagepic_blue[extent_x * loopy + loopx] =                        (themask);            }        }    }}